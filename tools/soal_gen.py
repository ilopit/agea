import sys
import os


default_header = """// Smart Object Autogenerated Layout

// clang-format off

#include "model/caches/caches_map.h"
#include "model/caches/empty_objects_cache.h"
#include "model/caches/objects_cache.h"

#include "model/reflection/lua_api.h"

#include "model/object_constructor.h"

#include "model/package_manager.h"
#include "model/package.h"

#include "{module_name}/{module_name}_module.h"

#include <sol2_unofficial/sol.h>

"""

default_content = """
bool 
{module_name}_module::init_reflection()
{{
    auto pkg = std::make_unique<agea::model::package>(AID("{module_name}"));

"""

default_footer = """
    ::agea::reflection::object_reflection::fill_properties();

    ::agea::glob::package_manager::getr().register_package(pkg);

    return true;
}}
// clang-format on
"""

modules_instance_template = """
{module_name}_module&
{module_name}_module::instance()
{{
    static {module_name}_module s_module(AID("{module_name}"));
    return s_module;
}}"""

methods_template = """
void
{type}::set_{property}({property_type} v)
{{
    m_{property} = v;
}}

{property_type}
{type}::get_{property}() const
{{
    return m_{property};
}}"""

methods_template_ref = """
void
{type}::set_{property}({property_type} v)
{{
    *m_{property} = v;
}}

{property_type}
{type}::get_{property}() const
{{
    return *m_{property};
}}"""

methods_template_decl = """
{get_access}:\\
{property_type} get_{property}() const;\\
{set_access}:\\
void set_{property}({property_type} v);\\"""

methods_template_decl_ref = """
{get_access}:\\
{property_type} get_{property}() const;\\
{set_access}:\\
void set_{property}({property_type} v);\\"""

soal_template = """
::agea::utils::id
{type}::META_type_id()
{{
    return AID("{type}");
}}

void 
{type}::META_class_set_type_id()
{{
    m_type_id = META_type_id();
}}

void 
{type}::META_class_set_architype_id()
{{
    m_architype_id = META_architype_id();
}}

::agea::reflection::object_reflection*
{type}::META_object_reflection()
{{
    static ::agea::reflection::object_reflection rt{{
        std::is_same<this_class, base_class>::value
            ? nullptr
            : base_class::META_object_reflection(), META_type_id()}};
    return &rt;
}}

const ::agea::reflection::object_reflection*
{type}::reflection() const
{{
    return this_class::META_object_reflection();
}}

bool
{type}::META_construct(const ::agea::model::smart_object::construct_params& i)
{{
    /* Replace to dynamic cast */
    this_class::construct_params* cp = (this_class::construct_params*)&i;

    return construct(*cp);
}}

std::shared_ptr<::agea::model::smart_object>
{type}::META_create_empty_obj()
{{
    return this_class::META_class_create_empty_obj();
}}

std::shared_ptr<{type}>
{type}::META_class_create_empty_obj()
{{
    auto s = std::make_shared<this_class>();
    s->META_class_set_type_id();
    s->META_class_set_architype_id();
    return s;
}}
"""

empty_template = """
{{
    using type = {type};
    pkg->register_type<type>();
    auto dummy = type::META_object_reflection();
    (void)dummy;
}}
"""


property_template_start = """
{{
    using type       = {type};

    auto prop        = std::make_shared<::agea::reflection::property>();
    auto p           = prop.get();
    auto table       = type::META_object_reflection();

    table->m_properties.emplace_back(std::move(prop));

    // Main fields
    p->name                           = "{property}";
    p->offset                         = offsetof(type, m_{property});
    p->size                           = sizeof(type::m_{property});
    p->rtype                           = ::agea::glob::reflection_type_registry::getr().get_type(::agea::reflection::type_resolver::resolve<decltype(type::m_{property})>().type);
    // Extra fields
"""
property_template_end = """
}
"""

lua_binding_class_template = """
    {{
        static sol::usertype<{type}> lua_type = ::agea::glob::lua_api::getr().state().new_usertype<{type}>(
        "{type}", sol::no_constructor,
            "i",
            [](const char* id) -> {type}*
            {{
                auto item = ::agea::glob::objects_cache::get()->get_item(AID(id));

                if(!item)
                {{
                    return nullptr;
                }}

                return item->as<{type}>();
            }},
            "c",
            [](const char* id) -> {type}*
            {{
                auto item = ::agea::glob::class_objects_cache::get()->get_item(AID(id));

                if(!item)
                {{
                    return nullptr;
                }}

                return item->as<{type}>();
            }}{lua_end}
        );
"""

lua_binding_struct_template = """
    {{
        static sol::usertype<{type}> lua_type = ::agea::glob::lua_api::getr().state().new_usertype<{type}>(
        "{type}", sol::constructors<{ctor_line}>()
        );
"""

lua_binding_template_end = """
    }"""

lua_binding_template_get_function = """
        lua_type["get_{property}"] = &{type}::get_{property};"""

lua_binding_template_set_function = """
        lua_type["set_{property}"] = &{type}::set_{property};"""


def extstrip(value: str):
    removal_list = [' ', '\t', '\n', '\r']
    for s in removal_list:
        value = value.replace(s, '')
    return value


class file_context:
    def __init__(self, module_name):

        full_module_name = module_name
        if module_name == "model":
            full_module_name = "agea::" + module_name

        self.header = default_header.format(module_name=module_name)
        self.includes = set()
        self.content = ""
        self.footer = default_footer.format(full_module_name=full_module_name)
        self.soal = ""
        self.empty_cache = ""
        self.methods = ""
        self.lua_binding = ""
        self.lua_ctor = ""


class agea_class:
    def __init__(self):
        self.name = ""
        self.parent = ""
        self.properties = []
        self.functions = []


class agea_struct:
    def __init__(self):
        self.name = ""
        self.ctros = []
        self.functions = []


class agea_function:
    def __init__(self):
        self.name = ""


class agea_ctor:
    def __init__(self):
        self.name = ""


class agea_property:
    def __init__(self):
        self.name = ""
        self.category = ""
        self.type = ""
        self.access = "cpp_only"
        self.owner = ""
        self.hint = ""
        self.serializable = "false"
        self.property_ser_handler = ""
        self.property_des_handler = ""
        self.property_prototype_handler = ""
        self.property_compare_handler = ""
        self.property_copy_handler = ""
        self.gpu_data = ""
        self.copyable = "yes"
        self.updatable = "yes"
        self.ref = "false"
        self.has_default = "false"


def write_properties(context: file_context, prop: agea_property, current_class: agea_class, module_name: str):

    context.content += property_template_start.format(module_name=module_name,
                                                      property=prop.name[2:], property_type=prop.type, type=prop.owner)

    if prop.access != "no":
        if prop.ref == "false":
            context.methods += methods_template.format(
                module_name=module_name,
                property=prop.name[2:], property_type=prop.type, type=prop.owner)
        else:
            context.methods += methods_template_ref.format(
                module_name=module_name,
                property=prop.name[2:], property_type=prop.type, type=prop.owner)

    if prop.access == "all" or prop.access == "read_only":
        context.lua_binding += lua_binding_template_get_function.format(
            module_name=module_name,
            property=prop.name[2:], property_type=prop.type, type=prop.owner)

    if prop.access == "all":
        context.lua_binding += lua_binding_template_set_function.format(
            module_name=module_name,
            property=prop.name[2:], property_type=prop.type, type=prop.owner)

    if prop.category != "":
        context.content += "    "
        context.content += 'p->category                       = "{0}";\n'.format(
            prop.category)

    if prop.gpu_data != "":
        context.content += "    "
        context.content += 'p->gpu_data                       = "{0}";\n'.format(
            prop.gpu_data)

    if prop.has_default == "true":
        context.content += "    "
        context.content += 'p->has_default                    = {0};\n'.format(
            prop.has_default)

    if prop.hint != "":
        context.content += "    "
        context.content += 'p->hints                          = {{{0}}};\n'.format(
            prop.hint)

    if prop.serializable == "true":
        context.content += "    "
        context.content += 'p->serializable                   = true;\n'

    if prop.property_ser_handler != "":
        context.content += "    "
        context.content += 'p->serialization_handler          = ::agea::reflection::{0};\n'.format(
            prop.property_ser_handler)

    if prop.property_des_handler != "":
        context.content += "    "
        context.content += 'p->deserialization_handler        = ::agea::reflection::{0};\n'.format(
            prop.property_des_handler)

    if prop.property_prototype_handler != "":
        context.content += "    "
        context.content += 'p->protorype_handler              = ::agea::reflection::{0};\n'.format(
            prop.property_prototype_handler)

    if prop.property_compare_handler != "":
        context.content += "    "
        context.content += 'p->compare_handler                = ::agea::reflection::{0};\n'.format(
            prop.property_compare_handler)

    if prop.property_copy_handler != "":
        context.content += "    "
        context.content += 'p->copy_handler                   = ::agea::reflection::{0};\n'.format(
            prop.property_copy_handler)

    context.content += property_template_end


def setter_access_kw(w: str):
    return {"cpp_read_only": "protected", "cpp_only": "public", "read_only": "protected", "all": "public"}.get(w)


def getter_access_kw(w: str):
    return {"cpp_read_only": "public", "cpp_only": "public", "read_only": "public", "all": "public"}.get(w)


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def write_lua_class_type(context: file_context, current_class: agea_class, module_name):
    if current_class.parent == '':
        context.lua_binding += lua_binding_class_template.format(
            module_name=module_name, type=current_class.name, lua_end='')
    else:
        context.lua_binding += lua_binding_class_template.format(
            module_name=module_name, type=current_class.name, lua_end=',sol::base_classes, sol::bases<' + current_class.parent + '>()')


def write_lua_struct_type(context: file_context, current_struct: agea_struct, module_name: str):

    ctro_line = ''
    for c in current_struct.ctros:
        ctro_line += c.name
        ctro_line += ','

    context.lua_binding += lua_binding_struct_template.format(
        module_name=module_name,
        type=current_struct.name, ctor_line=ctro_line[:-1]

    )


def process_file(original_file_full_path, original_file_rel_path, module_name, context: file_context):

    eprint("processing : {0} ...".format(original_file_full_path))

    class_name = os.path.basename(original_file_full_path)[:-2]

    cfg = open(original_file_full_path, 'r')
    lines = cfg.readlines()
    lines_count = len(lines)

    i = 0

    current_class = None
    current_struct = None

    while i != lines_count:
        line = lines[i].strip()

        if line.startswith("AGEA_class()"):

            if current_class is None:
                current_class = agea_class()

            i = i + 1
            final_tokens = []
            class_tokens = lines[i].replace(
                " : ", " ").replace("\n", " ").replace(",", " ").split(" ")
            for t in class_tokens:
                if t not in {"class", "public", "private", str()}:
                    final_tokens.append(t)

            current_class.name = final_tokens[0]
            if len(final_tokens) > 1:
                current_class.parent = final_tokens[1]

        if line.startswith("AGEA_struct()"):

            if current_struct is None:
                current_struct = agea_struct()

            i = i + 1
            final_tokens = []
            class_tokens = lines[i].replace(
                ":", " ").replace("\n", " ").replace(",", " ").split(" ")
            for t in class_tokens:
                if t not in {"struct", "public", "private", str()}:
                    final_tokens.append(t)

            current_struct.name = final_tokens[0]

        if line.startswith("AGEA_function"):

            function_header_like = ""
            function_body_like = ""

            current_fucntion = agea_function()
            function_header_like += line + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                function_header_like += lines[i].strip() + " "

            i = i + 1
            function_body_like += lines[i] + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                function_body_like += lines[i].strip() + " "

            function_body_like = function_body_like.strip().replace("\n", " ")
            fff = function_body_like.split(" ")

            matches = next(x for x in fff if x.find("(") != -1)
            current_fucntion.name = matches[:matches.find("(")]
            if current_class:
                current_class.functions.append(current_fucntion)

            if current_struct:
                current_struct.functions.append(current_fucntion)

        if line.startswith("AGEA_property"):
            property_like = line + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                property_like += lines[i].strip() + " "

            i = i + 1
            field_tokens = lines[i].strip()[:-1].split()

            prop = agea_property()
            property_raw = property_like[property_like.find(
                "(") + 1:property_like.find(")")].split(", ")

            for pf in property_raw:
                pairs = pf.strip().split("=")
                eprint("DBG! {0}".format(pairs))
                pairs[0] = pairs[0][1:]
                pairs[1] = pairs[1][:-1]

                if len(pairs) != 2:
                    eprint("Wrong numbers of pairs! {0}".format(pairs))
                    exit(-1)

                if pairs[0] == "category":
                    prop.category = pairs[1]
                elif pairs[0] == "serializable":
                    prop.serializable = pairs[1]
                elif pairs[0] == "property_ser_handler":
                    prop.property_ser_handler = pairs[1]
                elif pairs[0] == "property_des_handler":
                    prop.property_des_handler = pairs[1]
                elif pairs[0] == "property_prototype_handler":
                    prop.property_prototype_handler = pairs[1]
                elif pairs[0] == "property_compare_handler":
                    prop.property_compare_handler = pairs[1]
                elif pairs[0] == "property_copy_handler":
                    prop.property_copy_handler = pairs[1]
                elif pairs[0] == "access":
                    prop.access = pairs[1]
                elif pairs[0] == "default":
                    prop.has_default = pairs[1]
                    if (len(field_tokens) < 3 or field_tokens[2] != "="):
                        eprint("Please provide default arument")
                        exit(-1)
                elif pairs[0] == "gpu_data":
                    prop.gpu_data = pairs[1]
                elif pairs[0] == "copyable":
                    prop.copyable = pairs[1]
                elif pairs[0] == "updatable":
                    prop.copyable = pairs[1]
                elif pairs[0] == "ref":
                    prop.ref = pairs[1]
                elif pairs[0] == "hint":
                    tokens = pairs[1].split(",")
                    prop.hint += ""
                    for t in tokens:
                        prop.hint += "\""
                        prop.hint += t
                        prop.hint += "\","
                    if len(prop.hint) > 0:
                        prop.hint = prop.hint[:-1]
                    prop.hint += ""
                else:
                    eprint("Unsupported property = " + pairs[0])
                    exit(-1)

            prop.type = field_tokens[0]
            prop.name = field_tokens[1]

            prop.owner = class_name
            current_class.properties.append(prop)

        if line.startswith("AGEA_ctor"):
            ctor_body_like = ""
            ctor = agea_ctor()
            ctor_header_like = line + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                ctor_header_like += lines[i].strip() + " "

            i = i + 1
            ctor_body_like += lines[i] + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                ctor_body_like += lines[i].strip() + " "

            ctor.name = ctor_body_like.strip().replace("\n", " ")
            current_struct.ctros.append(ctor)

        i = i + 1

    if current_class:
        context.soal += soal_template.format(
            module_name=module_name, type=class_name)

        context.empty_cache += empty_template.format(
            module_name=module_name, type=class_name)

        write_lua_class_type(context, current_class, module_name)

        for p in current_class.properties:
            write_properties(context, p, current_class, module_name)

        for p in current_class.functions:
            context.lua_binding += """       lua_type["{0}"] = &{1}::{0};
""".format(p.name, current_class.name)

        context.lua_binding += lua_binding_template_end

    if current_struct:
        write_lua_struct_type(context, current_struct, module_name)

        for p in current_struct.functions:
            context.lua_binding += """       lua_type["{0}"] = &{1}::{0};
""".format(p.name, current_struct.name)

        context.lua_binding += lua_binding_template_end

    include = '#include "' + original_file_rel_path + '"'

    context.includes.add(include)


def write_file(output_file, context, module_name):
    output = open(output_file, "w")
    output.write(context.header)
    output.write("\n\n")

    l = list(context.includes)
    l.sort()

    for i in l:
        output.write(i)
        output.write("\n")

    full_module_name = module_name
    if module_name == "model":
        full_module_name = "agea::" + module_name

    output.write("\n\n")
    output.write("namespace {full_module_name} {{".format(
        full_module_name=full_module_name))
    output.write("\n\n")
    output.write(context.soal)
    output.write("\n\n")
    output.write(default_content.format(module_name=module_name))
    output.write("\n\n")
    output.write(context.empty_cache)
    output.write("\n\n")
    output.write(context.content)
    output.write("\n\n")
    output.write(context.lua_binding)
    output.write("\n\n")
    output.write(context.footer)
    output.write("\n\n")
    output.write(context.methods)
    output.write("\n\n")
    output.write(modules_instance_template.format(module_name=module_name))
    output.write("\n\n")
    output.write("}")


def write_single_file(output_dir, file_path, package_name):
    class_name = os.path.basename(file_path)[:-2]

    full_file_path = os.path.basename(file_path)[:-2] + ".generated.h"

    header_file_content = f"""
#pragma once

#define AGEA_gen_meta__{class_name}()\\"""
    cfg = open(file_path, 'r')
    lines = cfg.readlines()
    lines_count = len(lines)
    i = 0
    while i != lines_count:
        line = lines[i].strip()

        property_like = ""

        # TODO, rewrite!
        if line.startswith("AGEA_property"):
            property_like += line + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                property_like += lines[i].strip() + " "

            i = i + 1
            field = lines[i].strip()[:-1].split()

            prop = agea_property()
            property_raw = property_like[property_like.find(
                "(") + 1:property_like.find(")")].split(", ")

            for pf in property_raw:
                pf = pf.strip()
                pairs = pf.split("=")
                pairs[0] = pairs[0][1:]
                pairs[1] = pairs[1][:-1]

                if len(pairs) != 2:
                    eprint("Wrong numbers of pairs! {0}".format(pairs))
                    exit(-1)

                if pairs[0] == "getter":
                    prop.getter = pairs[1]
                elif pairs[0] == "setter":
                    prop.setter = pairs[1]
                elif pairs[0] == "ref":
                    prop.ref = pairs[1]
                elif pairs[0] == "access":
                    prop.access = pairs[1]
                else:
                    eprint("Unknown property!")

            prop.type = field[0]
            prop.name = field[1]
            prop.owner = class_name

            if prop.access != "no":
                if prop.ref == "false":
                    header_file_content += methods_template_decl.format(
                        property_type=prop.type, property=prop.name[2:], get_access=getter_access_kw(prop.access), set_access=setter_access_kw(prop.access))
                else:
                    header_file_content += methods_template_decl_ref.format(
                        property_type=prop.type[:-1], property=prop.name[2:], get_access=getter_access_kw(prop.access), set_access=setter_access_kw(prop.access))

        i = i + 1
    header_file_content += "\nprivate:"

    full_file_path = os.path.join(output_dir, package_name, full_file_path)
    with open(full_file_path, 'w') as file:
        file.write(header_file_content)


def main(ar_cfg_path, root_dir, output_dir, module_name):

    print("SOLing : SOL config - {0}, root dir - {1}, output - {2}, package_name - {3}".format(
        ar_cfg_path, root_dir, output_dir, module_name))

    context = file_context(module_name)
    cfg = open(ar_cfg_path, 'r', newline='\n')
    lines = cfg.readlines()
    for f in lines:
        f = extstrip(f)
        if len(f) > 0:
            file_path = os.path.join(root_dir, f).replace("\\", "/")
            process_file(file_path, f, module_name, context)
            write_single_file(output_dir, file_path, module_name)

    output_file = os.path.join(
        output_dir, module_name,  module_name + ".ar.cpp")

    write_file(output_file, context, module_name)


if __name__ == "__main__":
    main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4])
