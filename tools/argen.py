import sys
import os


default_header = """// Smart Object Autogenerated Layout

// clang-format off

#include "model/caches/caches_map.h"
#include "model/caches/empty_objects_cache.h"
#include "model/caches/objects_cache.h"

#include "model/reflection/lua_api.h"

#include "model/object_constructor.h"

#include "model/package_manager.h"
#include "model/package.h"

#include "{module_name}/{module_name}_module.h"
#include "{module_name}/{module_name}_types_ids.ar.h"
#include "{module_name}/{module_name}_types_resolvers.ar.h"
{custom_include}

#include <sol2_unofficial/sol.h>

"""

default_content = """
bool
{module_name}_module::init_reflection()
{{
    auto pkg = std::make_unique<agea::model::package>(AID("{module_name}"));

"""

default_footer = """
    //::agea::reflection::object_reflection::fill_properties();

    ::agea::glob::package_manager::getr().register_package(pkg);

    return true;
}}
// clang-format on
"""

modules_instance_template = """
{module_name}_module&
{module_name}_module::instance()
{{
    static {module_name}_module s_module(AID("{module_name}"));
    return s_module;
}}"""

methods_template = """
void
{type}::set_{property}({property_type} v)
{{
    m_{property} = v;
}}

{property_type}
{type}::get_{property}() const
{{
    return m_{property};
}}"""

methods_template_ref = """
void
{type}::set_{property}({property_type} v)
{{
    *m_{property} = v;
}}

{property_type}
{type}::get_{property}() const
{{
    return *m_{property};
}}"""

methods_template_decl = """
{get_access}:\\
{property_type} get_{property}() const;\\
{set_access}:\\
void set_{property}({property_type} v);\\"""

methods_template_decl_ref = """
{get_access}:\\
{property_type} get_{property}() const;\\
{set_access}:\\
void set_{property}({property_type} v);\\"""

soal_template = """
::agea::utils::id
{type}::META_type_id()
{{
    return AID("{type}");
}}

void
{type}::META_class_set_type_id()
{{
    m_type_id = META_type_id();
}}

void
{type}::META_class_set_architype_id()
{{
    m_architype_id = META_architype_id();
}}

const ::agea::reflection::reflection_type*
{type}::reflection() const
{{
    return this_class::META_reflection_type();
}}

bool
{type}::META_construct(const ::agea::root::smart_object::construct_params& i)
{{
    /* Replace to dynamic cast */
    this_class::construct_params* cp = (this_class::construct_params*)&i;

    return construct(*cp);
}}

std::shared_ptr<::agea::root::smart_object>
{type}::META_create_empty_obj()
{{
    return this_class::META_class_create_empty_obj();
}}

std::shared_ptr<{type}>
{type}::META_class_create_empty_obj()
{{
    auto s = std::make_shared<this_class>();
    s->META_class_set_type_id();
    s->META_class_set_architype_id();
    return s;
}}
"""

empty_template_with_parent = """
{{
    auto type_id = ::agea::reflection::type_resolver<{type}>::resolver();
    AGEA_check(type_id != -1, "Type is not defined!");

    auto type = ::agea::glob::reflection_type_registry::getr().get_type(type_id);
    AGEA_check(type, "Type is not defined!");

    auto parent_type_id = ::agea::reflection::type_resolver<{parent}>::resolver();
    AGEA_check(parent_type_id != -1, "Type is not defined!");

    auto parent = ::agea::glob::reflection_type_registry::getr().get_type(parent_type_id);
    AGEA_check(parent, "Type is not defined!");

    type->parent = parent;
}}
"""

empty_template = """
{{
    auto type_id = ::agea::reflection::type_resolver<{type}>::resolver();
    AGEA_check(type_id != -1, "Type is not defined!");

    ::agea::reflection::reflection_type rt;
    rt.type_id      = type_id;
    rt.type_name    = AID("{short_type}");
    rt.module_id    = AID("{module_name}");
    rt.size         = sizeof({type});

    ::agea::glob::reflection_type_registry::getr().add_type(std::move(rt));
"""

smart_object_type_decl = """
    auto type = ::agea::glob::reflection_type_registry::getr().get_type(type_id);
    AGEA_check(type, "Type is not defined!");

    {type}::META_reflection_type() = type;

    pkg->register_type<{type}>();
"""


type_template = """
{{
    ::agea::reflection::reflection_type rt;
    rt.type_id   = type_id;
    rt.module_id = AID("{module_name}");
    rt.size = sizeof({type});

    ::agea::glob::reflection_type_registry::getr().add_type(std::move(rt));

"""

type_resolver = """
template <>
struct type_resolver<{full_type}>
{{
static int
resolver()
{{
    return  ::{full_module_name}::{module_name}__{type};
}}
}};
"""


property_template_start = """
{{
    using type       = {type};

    auto td          = ::agea::reflection::agea_type_resolve<{type}>();
    auto property_td = ::agea::reflection::agea_type_resolve<decltype(type::m_{property})>();

    auto rtype       = ::agea::glob::reflection_type_registry::getr().get_type(td.type_id);
    auto prop_rtype  = ::agea::glob::reflection_type_registry::getr().get_type(property_td.type_id);

    auto prop        = std::make_shared<::agea::reflection::property>();
    auto p           = prop.get();

    rtype->m_properties.emplace_back(std::move(prop));

    // Main fields
    p->name                           = "{property}";
    p->offset                         = offsetof(type, m_{property});
    p->rtype                          = prop_rtype;
    // Extra fields
"""
property_template_end = """
}
"""

lua_binding_class_template = """
    {{
        static sol::usertype<{type}> lua_type = ::agea::glob::lua_api::getr().state().new_usertype<{type}>(
        "{type}", sol::no_constructor,
            "i",
            [](const char* id) -> {type}*
            {{
                auto item = ::agea::glob::objects_cache::get()->get_item(AID(id));

                if(!item)
                {{
                    return nullptr;
                }}

                return item->as<{type}>();
            }},
            "c",
            [](const char* id) -> {type}*
            {{
                auto item = ::agea::glob::class_objects_cache::get()->get_item(AID(id));

                if(!item)
                {{
                    return nullptr;
                }}

                return item->as<{type}>();
            }}{lua_end}
        );
"""

lua_binding_struct_template = """
    {{
        static sol::usertype<{type}> lua_type = ::agea::glob::lua_api::getr().state().new_usertype<{type}>(
        "{type}", sol::constructors<{ctor_line}>()
        );
"""

lua_binding_template_end = """
    }"""

lua_binding_template_get_function = """
        lua_type["get_{property}"] = &{type}::get_{property};"""

lua_binding_template_set_function = """
        lua_type["set_{property}"] = &{type}::set_{property};"""


def extstrip(value: str):
    removal_list = [' ', '\t', '\n', '\r']
    for s in removal_list:
        value = value.replace(s, '')
    return value


class file_context:
    def __init__(self, module_name, module_namespace, first_type_id: int):
        self.module_name = module_name
        if module_namespace:
            self.full_module_name = module_namespace + "::" + module_name
        else:
            self.full_module_name = module_name

        self.includes = set()
        self.types = list()
        self.custom_types = list()
        self.content = ""
        self.footer = default_footer.format(
            full_module_name=self.full_module_name)
        self.soal = ""
        self.empty_cache = ""
        self.parent = ""
        self.methods = ""
        self.lua_binding = ""
        self.lua_ctor = ""
        self.has_custom_types = False
        self.has_custom_properties = False
        self.first_type_id = first_type_id


class agea_class:
    def __init__(self):
        self.name = ""
        self.parent = ""
        self.properties = []
        self.functions = []


class agea_struct:
    def __init__(self):
        self.name = ""
        self.ctros = []
        self.functions = []


class agea_function:
    def __init__(self):
        self.name = ""


class agea_ctor:
    def __init__(self):
        self.name = ""


class agea_property:
    def __init__(self):
        self.name = ""
        self.category = ""
        self.type = ""
        self.access = "cpp_only"
        self.owner = ""
        self.hint = ""
        self.serializable = "false"
        self.property_ser_handler = ""
        self.property_des_handler = ""
        self.property_prototype_handler = ""
        self.property_compare_handler = ""
        self.property_copy_handler = ""
        self.gpu_data = ""
        self.copyable = "yes"
        self.updatable = "yes"
        self.ref = "false"
        self.has_default = "false"


def write_properties(context: file_context, prop: agea_property, current_class: agea_class, module_name: str):

    context.content += property_template_start.format(module_name=module_name,
                                                      property=prop.name[2:], property_type=prop.type, type=prop.owner)
    if prop.access != "no":
        if prop.ref == "false":
            context.methods += methods_template.format(
                module_name=module_name,
                property=prop.name[2:], property_type=prop.type, type=prop.owner)
        else:
            context.methods += methods_template_ref.format(
                module_name=module_name,
                property=prop.name[2:], property_type=prop.type, type=prop.owner)

    if prop.access == "all" or prop.access == "read_only":
        context.lua_binding += lua_binding_template_get_function.format(
            module_name=module_name,
            property=prop.name[2:], property_type=prop.type, type=prop.owner)

    if prop.access == "all":
        context.lua_binding += lua_binding_template_set_function.format(
            module_name=module_name,
            property=prop.name[2:], property_type=prop.type, type=prop.owner)

    if prop.category != "":
        context.content += "    "
        context.content += 'p->category                       = "{0}";\n'.format(
            prop.category)

    if prop.gpu_data != "":
        context.content += "    "
        context.content += 'p->gpu_data                       = "{0}";\n'.format(
            prop.gpu_data)

    if prop.has_default == "true":
        context.content += "    "
        context.content += 'p->has_default                    = {0};\n'.format(
            prop.has_default)

    if prop.hint != "":
        context.content += "    "
        context.content += 'p->hints                          = {{{0}}};\n'.format(
            prop.hint)

    if prop.serializable == "true":
        context.content += "    "
        context.content += 'p->serializable                   = true;\n'

    if prop.property_ser_handler != "":
        context.content += "    "
        context.content += 'p->serialization_handler          = ::agea::reflection::{0};\n'.format(
            prop.property_ser_handler)

    if prop.property_des_handler != "":
        context.content += "    "
        context.content += 'p->deserialization_handler        = ::agea::reflection::{0};\n'.format(
            prop.property_des_handler)

    if prop.property_prototype_handler != "":
        context.content += "    "
        context.content += 'p->protorype_handler              = ::agea::reflection::{0};\n'.format(
            prop.property_prototype_handler)

    if prop.property_compare_handler != "":
        context.content += "    "
        context.content += 'p->compare_handler                = ::agea::reflection::{0};\n'.format(
            prop.property_compare_handler)

    if prop.property_copy_handler != "":
        context.content += "    "
        context.content += 'p->copy_handler                   = ::agea::reflection::{0};\n'.format(
            prop.property_copy_handler)

    context.content += property_template_end


def setter_access_kw(w: str):
    return {"cpp_read_only": "protected", "cpp_only": "public", "read_only": "protected", "all": "public"}.get(w)


def getter_access_kw(w: str):
    return {"cpp_read_only": "public", "cpp_only": "public", "read_only": "public", "all": "public"}.get(w)


def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)


def write_lua_class_type(context: file_context, current_class: agea_class, module_name):
    if current_class.parent == '':
        context.lua_binding += lua_binding_class_template.format(
            module_name=module_name, type=current_class.name, lua_end='')
    else:
        context.lua_binding += lua_binding_class_template.format(
            module_name=module_name, type=current_class.name, lua_end=',sol::base_classes, sol::bases<' + current_class.parent + '>()')


def write_lua_struct_type(context: file_context, current_struct: agea_struct, module_name: str):

    ctro_line = ''
    for c in current_struct.ctros:
        ctro_line += c.name
        ctro_line += ','

    context.lua_binding += lua_binding_struct_template.format(
        module_name=module_name,
        type=current_struct.name, ctor_line=ctro_line[:-1]

    )


def to_type_id(type, is_parent,  context: file_context):
    if is_parent:
        return type.split("::")[-2] + "__" + type.split("::")[-1]

    return context.module_name + "__" + type


def process_file(original_file_full_path, original_file_rel_path, module_name, context: file_context):

    eprint("processing : {0} ...".format(original_file_full_path))

    class_name = os.path.basename(original_file_full_path)[:-2]

    cfg = open(original_file_full_path, 'r')
    lines = cfg.readlines()
    lines_count = len(lines)

    i = 0

    current_class = None
    current_struct = None

    while i != lines_count:
        line = lines[i].strip()

        if line.startswith("AGEA_ar_class()"):

            if current_class is None:
                current_class = agea_class()

            i = i + 1
            final_tokens = []
            class_tokens = lines[i].replace(
                " : ", " ").replace("\n", " ").replace(",", " ").split(" ")
            for t in class_tokens:
                if t not in {"class", "public", "private", str()}:
                    final_tokens.append(t)

            current_class.name = final_tokens[0]
            if len(final_tokens) > 1:
                current_class.parent = final_tokens[1]

        if line.startswith("AGEA_ar_struct()"):

            if current_struct is None:
                current_struct = agea_struct()

            i = i + 1
            final_tokens = []
            class_tokens = lines[i].replace(
                " : ", " ").replace("\n", " ").replace(",", " ").split(" ")
            for t in class_tokens:
                if t not in {"struct", "public", "private", str()}:
                    final_tokens.append(t)

            current_struct.name = final_tokens[0]

        if line.startswith("AGEA_ar_function"):

            function_header_like = ""
            function_body_like = ""

            current_fucntion = agea_function()
            function_header_like += line + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                function_header_like += lines[i].strip() + " "

            i = i + 1
            function_body_like += lines[i] + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                function_body_like += lines[i].strip() + " "

            function_body_like = function_body_like.strip().replace("\n", " ")
            fff = function_body_like.split(" ")

            matches = next(x for x in fff if x.find("(") != -1)
            current_fucntion.name = matches[:matches.find("(")]
            if current_class:
                current_class.functions.append(current_fucntion)

            if current_struct:
                current_struct.functions.append(current_fucntion)

        if line.startswith("AGEA_ar_property"):
            property_like = line + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                property_like += lines[i].strip() + " "

            i = i + 1
            field_tokens = lines[i].strip()[:-1].split()

            prop = agea_property()
            property_raw = property_like[property_like.find(
                "(") + 1:property_like.find(")")].split(", ")

            for pf in property_raw:
                pairs = pf.strip().split("=")
                eprint("DBG! {0}".format(pairs))
                pairs[0] = pairs[0][1:]
                pairs[1] = pairs[1][:-1]

                if len(pairs) != 2:
                    eprint("Wrong numbers of pairs! {0}".format(pairs))
                    exit(-1)

                if pairs[0] == "category":
                    prop.category = pairs[1]
                elif pairs[0] == "serializable":
                    prop.serializable = pairs[1]
                elif pairs[0] == "property_ser_handler":
                    prop.property_ser_handler = pairs[1]
                elif pairs[0] == "property_des_handler":
                    prop.property_des_handler = pairs[1]
                elif pairs[0] == "property_prototype_handler":
                    prop.property_prototype_handler = pairs[1]
                elif pairs[0] == "property_compare_handler":
                    prop.property_compare_handler = pairs[1]
                elif pairs[0] == "property_copy_handler":
                    prop.property_copy_handler = pairs[1]
                elif pairs[0] == "access":
                    prop.access = pairs[1]
                elif pairs[0] == "default":
                    prop.has_default = pairs[1]
                    if (len(field_tokens) < 3 or field_tokens[2] != "="):
                        eprint("Please provide default arument")
                        exit(-1)
                elif pairs[0] == "gpu_data":
                    prop.gpu_data = pairs[1]
                elif pairs[0] == "copyable":
                    prop.copyable = pairs[1]
                elif pairs[0] == "updatable":
                    prop.copyable = pairs[1]
                elif pairs[0] == "ref":
                    prop.ref = pairs[1]
                elif pairs[0] == "hint":
                    tokens = pairs[1].split(",")
                    prop.hint += ""
                    for t in tokens:
                        prop.hint += "\""
                        prop.hint += t
                        prop.hint += "\","
                    if len(prop.hint) > 0:
                        prop.hint = prop.hint[:-1]
                    prop.hint += ""
                else:
                    eprint("Unsupported property = " + pairs[0])
                    exit(-1)

            prop.type = field_tokens[0]
            prop.name = field_tokens[1]

            prop.owner = class_name
            current_class.properties.append(prop)

        if line.startswith("AGEA_ar_ctor"):
            ctor_body_like = ""
            ctor = agea_ctor()
            ctor_header_like = line + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                ctor_header_like += lines[i].strip() + " "

            i = i + 1
            ctor_body_like += lines[i] + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                ctor_body_like += lines[i].strip() + " "

            ctor.name = ctor_body_like.strip().replace("\n", " ")
            current_struct.ctros.append(ctor)

        if line.startswith("AGEA_ar_type("):
            pos = line.find(")")
            custom_type = line[len("AGEA_ar_type("): pos]

            context.custom_types.append(custom_type)

        i = i + 1

    if current_class:
        context.soal += soal_template.format(
            module_name=module_name, type=class_name)

        context.empty_cache += empty_template.format(
            module_name=module_name, type=class_name, short_type=class_name, child=current_class.name)

        context.empty_cache += smart_object_type_decl.format(
            type=class_name, child=current_class.name)

        context.empty_cache += "}\n"

        if len(current_class.parent) > 0:
            context.parent += empty_template_with_parent.format(
                module_name=module_name, type=class_name, child=current_class.name, parent=current_class.parent)

        write_lua_class_type(context, current_class, module_name)

        for p in current_class.properties:
            write_properties(context, p, current_class, module_name)

        for p in current_class.functions:
            context.lua_binding += """       lua_type["{0}"] = &{1}::{0};
""".format(p.name, current_class.name)

        context.lua_binding += lua_binding_template_end
        context.types.append(current_class.name)

    if current_struct:
        write_lua_struct_type(context, current_struct, module_name)

        for p in current_struct.functions:
            context.lua_binding += """       lua_type["{0}"] = &{1}::{0};
""".format(p.name, current_struct.name)

        context.lua_binding += lua_binding_template_end

    include = '#include "' + original_file_rel_path + '"'

    context.includes.add(include)


def from_custom_type(custom_type: str):
    return custom_type.split("::")[-1]


def write_types_ids_include(output_file, context):
    output = open(output_file, "w")

    total_types_size = len(context.custom_types)+len(context.types)

    if total_types_size == 0:
        return

    types_template_begin = """#pragma once

namespace {full_module_name} {{
   enum {{
"""

    output.write(types_template_begin.format(
        module_name=context.module_name, full_module_name=context.full_module_name))

    if len(context.custom_types) != 0:
        output.write('        // custom-types\n')

    normalized = []

    for t in context.custom_types:
        normalized.append(from_custom_type(t))

    normalized.sort()

    for t in normalized:
        output.write("        {module_name}__{type},\n".format(
            module_name=context.module_name, type=t))

    for t in context.types:
        normalized.append(t)

    if len(context.types) != 0:
        output.write('        // ag-types\n')

    for t in context.types:
        output.write("        {module_name}__{type},\n".format(
            module_name=context.module_name, type=t))

    enums_end = """        // ag-meta-types
        {module_name}__first = {first},
        {module_name}__last  = {module_name}__{last_type},
        {module_name}__count = {size}"""
    output.write(enums_end.format(module_name=context.module_name,
                                  last_type=normalized[-1], size=total_types_size, first=context.first_type_id))

    types_template_end = """
   };
}
"""
    output.write(types_template_end)


def write_types_resolvers(output_file, context):
    output = open(output_file, "w")

    types_template_begin = """#pragma once


#include "model/reflection/types.h"

#include "{module_name}/{module_name}_types_ids.ar.h"

"""
    output.write(types_template_begin.format(module_name=context.module_name))

    l = list(context.includes)
    l.sort()

    for i in l:
        output.write(i)
        output.write("\n")

    ns = """
namespace agea::reflection
{
"""
    output.write(ns)

    for t in context.types:
        output.write(type_resolver.format(module_name=context.module_name,
                     full_module_name=context.full_module_name, type=t, full_type=context.full_module_name + "::" + t))

    for t in context.custom_types:
        output.write(type_resolver.format(module_name=context.module_name,
                     full_module_name=context.full_module_name, full_type=t, type=from_custom_type(t)))

    output.write("}\n")


def write_file(output_file, context: file_context):
    output = open(output_file, "w")

    custom_include = ""
    if context.has_custom_types:
        custom_include += """#include "{module_name}/{module_name}_types_custom.h"
""".format(
            module_name=context.module_name)

    if context.has_custom_properties:
        custom_include += """#include "{module_name}/{module_name}_properties_custom.h"
""".format(
            module_name=context.module_name)

    output.write(default_header.format(
        module_name=context.module_name, custom_include=custom_include))
    output.write("\n\n")

    l = list(context.includes)
    l.sort()

    for i in l:
        output.write(i)
        output.write("\n")

    output.write("\n\n")
    output.write("namespace {full_module_name} {{".format(
        full_module_name=context.full_module_name))
    output.write("\n\n")
    output.write(context.soal)
    output.write("\n\n")
    output.write(default_content.format(module_name=context.module_name))
    output.write("\n\n")

    for t in context.custom_types:
        output.write(empty_template.format(
            module_name=context.module_name, type=t, short_type=from_custom_type(t)))
        output.write("\n}\n")

    output.write(context.empty_cache)
    output.write("\n\n")
    output.write(context.parent)
    output.write("\n\n")
    output.write(context.content)
    output.write("\n\n")
    output.write(context.lua_binding)
    output.write("\n\n")
    output.write(context.footer)
    output.write("\n\n")
    output.write(context.methods)
    output.write("\n\n")
    output.write(modules_instance_template.format(
        module_name=context.module_name))
    output.write("\n\n")
    output.write("}")


def write_single_file(output_dir, file_path, package_name):
    class_name = os.path.basename(file_path)[:-2]

    full_file_path = os.path.basename(file_path)[:-2] + ".generated.h"

    header_file_content = f"""
#pragma once

#include "{package_name}/{package_name}_module.h"

#define AGEA_gen_meta__{class_name}()   \\
    friend class {package_name}_module; \\"""

    cfg = open(file_path, 'r')
    lines = cfg.readlines()
    lines_count = len(lines)
    i = 0
    while i != lines_count:
        line = lines[i].strip()

        property_like = ""

        # TODO, rewrite!
        if line.startswith("AGEA_ar_property"):
            property_like += line + " "

            while i <= lines_count and lines[i].find(")") == -1:
                i = i + 1
                property_like += lines[i].strip() + " "

            i = i + 1
            field = lines[i].strip()[:-1].split()

            prop = agea_property()
            property_raw = property_like[property_like.find(
                "(") + 1:property_like.find(")")].split(", ")

            for pf in property_raw:
                pf = pf.strip()
                pairs = pf.split("=")
                pairs[0] = pairs[0][1:]
                pairs[1] = pairs[1][:-1]

                if len(pairs) != 2:
                    eprint("Wrong numbers of pairs! {0}".format(pairs))
                    exit(-1)

                if pairs[0] == "getter":
                    prop.getter = pairs[1]
                elif pairs[0] == "setter":
                    prop.setter = pairs[1]
                elif pairs[0] == "ref":
                    prop.ref = pairs[1]
                elif pairs[0] == "access":
                    prop.access = pairs[1]
                else:
                    eprint("Unknown property!")

            prop.type = field[0]
            prop.name = field[1]
            prop.owner = class_name

            if prop.access != "no":
                if prop.ref == "false":
                    header_file_content += methods_template_decl.format(
                        property_type=prop.type, property=prop.name[2:], get_access=getter_access_kw(prop.access), set_access=setter_access_kw(prop.access))
                else:
                    header_file_content += methods_template_decl_ref.format(
                        property_type=prop.type[:-1], property=prop.name[2:], get_access=getter_access_kw(prop.access), set_access=setter_access_kw(prop.access))

        i = i + 1
    header_file_content += "\nprivate:"

    full_file_path = os.path.join(output_dir, package_name, full_file_path)
    with open(full_file_path, 'w') as file:
        file.write(header_file_content)


def main(ar_cfg_path, root_dir, output_dir, module_name, module_namespace, first_type_id):

    print("SOLing : SOL config - {0}, root dir - {1}, output - {2}, package_name - {3}, module_namespace - {4}, first_type_id - {5}".format(
        ar_cfg_path, root_dir, output_dir, module_name, module_namespace, first_type_id))

    module_namespace = module_namespace.strip()

    context = file_context(module_name, module_namespace, first_type_id)

    context.has_custom_types = os.path.exists(
        os.path.join(
            root_dir, "include", module_name, module_name + "_types_custom.h"))

    context.has_custom_properties = os.path.exists(
        os.path.join(root_dir,  "include", module_name, module_name + "_properties_custom.h"))

    cfg = open(ar_cfg_path, 'r', newline='\n')
    lines = cfg.readlines()
    for f in lines:
        f = extstrip(f)
        if len(f) > 0:
            file_path = os.path.join(root_dir, f).replace("\\", "/")
            process_file(file_path, f, module_name, context)
            write_single_file(output_dir, file_path, module_name)

    output_file = os.path.join(
        output_dir, module_name,  module_name + ".ar.cpp")

    write_file(output_file, context)

    output_file = os.path.join(
        output_dir, module_name,  module_name + "_types_ids.ar.h")

    context.types.sort()
    context.custom_types.sort()

    write_types_ids_include(output_file, context)

    output_file = os.path.join(
        output_dir, module_name,  module_name + "_types_resolvers.ar.h")

    write_types_resolvers(output_file, context)


if __name__ == "__main__":
    main(sys.argv[1], sys.argv[2], sys.argv[3],
         sys.argv[4], sys.argv[5], sys.argv[6])
